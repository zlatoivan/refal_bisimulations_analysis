# Анализ бисимуляций Рефала

## Входные данные

Входными данными является файл, который содержит функции Рефала, разделенные Enter'ом.

Грамматика, задающая функцию Рефала:

    Function -> FuncName '{' Sentences '}'
    FuncName -> FUNC_IDENTIFIER
    Sentences -> Sentence | Sentence ';' | Sentence ';' Sentences
    Sentence -> Pattern '=' Expr

    Pattern -> PatternTerm Pattern | e
    PatternTerm -> STRING | Variable | '(' Pattern ')'

    Expr -> ExprTerm Expr | e
    ExprTerm -> STRING | Variable | '(' Expr ')' | '<' FuncName Expr '>'

    Variable -> Type Index
    Type -> TYPE
    Index -> VAR_IDENTIFIER

    FUNC_IDENTIFIER -> '[A-Z][A-Za-z0-9-_]{0,14}'
    VAR_IDENTIFIER -> '[.][A-Za-z0-9][A-Za-z0-9-_]{0,14}'
    STRING -> '\'[A-Za-z0-9]+\''
    TYPE -> '[ste]{1}'


*Пример input.txt:*

    F0 {
        'B' e.X = <H0 <G 'A'>>;
        'A' = 'ABC';
        () = ;
    }

    F {
        () = ;
        'A' = 'ABC';
        'B' e.X = <H <G 'A'>>;
    }

    H0 {
        'A' = 'ABC';
        'B' e.X = <G0 e.X>;
    }

    H {
        'A' = 'ABC';
        'B' e.X = <G e.X>;
    }

    G0 {
        'A' = ;
        'B' e.X = <G e.X>;
    }

    G {
        'A' = ;
        'B' e.X = <G e.X>;
    }

Примечания:
- Epsilon задается пустотой: " = <F 'A'>;"
- e.X и e.x - один и тот же объект


## Функционал программы

1) Построение синтаксических деревьев функций (не выводятся для экономии места)
2) Анализ биекций всех комбинаций функций и перестановочности правил, необходимых для бисимуляции. Программа выводит те перестановки, которые необходимо сделать, чтоб биекция была прямой.
3) Разбиение функций на классы эквивалентности
4) Выявление константных функций и разбиение их на классы по возвращаемой константе


## Выходные данные

*Пример выходных данных:*

    F0 {
        'B' e.X = <H0 <G 'A'>>;
        'A' = 'ABC';
        () = ;
    } 

    F {
        () = ;
        'A' = 'ABC';
        'B' e.X = <H <G 'A'>>;
    } 

    H0 {
        'A' = 'ABC';
        'B' e.X = <G0 e.X>;
    } 

    H {
        'A' = 'ABC';
        'B' e.X = <G e.X>;
    } 

    G0 {
        'A' = ;
        'B' e.X = <G e.X>;
    } 

    G {
        'A' = ;
        'B' e.X = <G e.X>;
    } 


    Биекция у F0 и F есть. У функции F0 предложения
    0 2
    0 1
    1 2
    перестановочны.

    -------------------------


    Классы эквивалентности:
        Класс 0: ['F0', 'F']
        Класс 1: ['H0', 'H']
        Класс 2: ['G0', 'G']


    Константные функции и их возвращаемые значения:
        ['F0', 'F'] -> ['eps', "'ABC'", "<H0 <G 'A'>>"]
        ['H0', 'H'] -> ["'ABC'", '<G0 e.X>']
        ['G0', 'G'] -> ['eps', '<G e.X>']


## Тестирование

Програма способна обрабатывать следующие интересные тесты:

### На классы эквивалентности (1):

Входные данные:

    F {
        'B' e.x = <F e.X>;
        'A' e.X2 = <G e.X2>;
        e.Z e.Z1 'C' e.Z = e.Z;
    }

    G {
        'A' e.X = <F e.X>;
        'B' e.X11 = <H e.X11>;
        e.5 e.Q 'C' e.5 = e.5;
    }

    H {
        'A' e.W = <H e.W>;
        'B' e.U = <G e.U>;
        e.V e.S 'C' e.V = e.V;
    }

Выходные данные:

    Биекция у F и G есть. У функции F предложения
    0 1
    перестановочны.

    -------------------------


    Классы эквивалентности:
        Класс 0: ['F', 'G', 'H']


    Константные функции и их возвращаемые значения:

---

### На классы эквивалентности (2):

Входные данные:

    F {
        e.X s.1 = <G s.1 <G e.X>>;
    } 

    G {
        e.X s.11 = <F s.11 <F e.X>>;
    } 


Выходные данные:

    Классы эквивалентности:
        Класс 0: ['F', 'G']


    Константные функции и их возвращаемые значения:

---

### На классы эквивалентности (3):

Входные данные:

    F {
        e.X s.1 = <R s.1 <G e.X>>;
    } 

    G {
        e.X s.11 = <F s.11 <H e.X>>;
    } 

    R {
        =;
    } 

    H {
        =;
    } 

Выходные данные:

    Классы эквивалентности:
        Класс 0: ['F']
        Класс 1: ['G']
        Класс 2: ['R', 'H']


    Константные функции и их возвращаемые значения:
        ['R', 'H'] -> ['eps']
